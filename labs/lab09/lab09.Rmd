---
title: "Stats 306: Lab 9"
author: "Your Name"
output: 
  learnr::tutorial:
    progressive: true
runtime: shiny_prerendered
---

## Set up

```{r installPackages, echo=FALSE, include=FALSE, message=FALSE}
# This just checks if students need to install some packages that they might 
# not have.

if (!packageVersion("learnr") == "0.11.1") install.packages("learnr", repos = "http://cran.us.r-project.org")
```

```{r setup, eval=TRUE, include=FALSE, message=FALSE, echo=FALSE}
library(learnr)     # For interactive exercises
library(tidyverse)  # For dplyr, stringr

tutorial_options(exercise.reveal_solution=TRUE)
```

```{r fake_setup, echo=TRUE, eval=FALSE}
library(learnr)     # For interactive exercises
library(tidyverse)  # For dplyr, stringr
```

## Logistics

- Exam 2 is due by 11:59 PM on Nov 11.
- Quiz 4 is due by 11:59 PM on Nov 20.
- Questions?

## Today's Content

- Strings and Regular Expressions

## Strings

Recall that a string is character data enclosed in double `"` or single `'` quotes. In R, strings exist in character vectors.
```{r}
words[1:5]
```

The `stringr` package contains many useful functions for working with strings. In lecture, we went over some commonly used `stringr` functions.

`str_c()` is used to concatenate strings. These strings can be given in separate vectors, in which case the `sep` argument should be used to control what goes between consecutive strings.
```{r}
str_c("lions", "tigers", "bears", "oh my!", sep = ", ")
```

`str_c()` can also be given a single vector of strings. In this case, the `collapse` argument should be used to control what goes between consecutive strings.
```{r}
parts <- c("lions", "tigers", "bears", "oh my!")
str_c(parts, collapse = ", ")
```

`str_length()` essentially returns the number of characters in a string.
```{r}
str_length("My favorite colors are maize and blue.")
```

`str_sub()` extracts a substring of a string. `start` and `end` are the indices of the starting and ending characters of the substring.
```{r}
str_sub("November", start = 3, end = 6)
```

`str_split()` splits a string into substrings given a separator. Note that it returns a list.
```{r}
str_split("lions, tigers, bears, oh my!", pattern = ", ")
```

## Exercises

### Question

Using the `letters` vector that's in base R, make one big 26-character string that contains every letter of the alphabet.

```{r str_c1, exercise=TRUE}

```

```{r str_c1-solution}
str_c(letters, collapse = "")
```

### Question

Using the `LETTERS` vector, make a vector with 25 strings in which the first string is `"A precedes B"`, the second string is `"B precedes C"`, etc.

```{r str_c2, exercise=TRUE}

```

```{r str_c2-hint}
# A start
str_c(LETTERS[-26], "precedes", sep = " ")
```

```{r str_c2-solution}
str_c(LETTERS[-26], "precedes", LETTERS[-1], sep = " ")
```

### Question

Finish writing the function `extract_substrs()` below. The function takes a string `s` and a length `l` and should return a vector containing the length `l` substrings of `s` that consist of consecutive characters. For example, `extract_substrs("cat", 2)` should evaluate to `c("ca", "at")`.

**Hint:** *Try using `:` or `seq_len()`*

```{r str_sub_str_length, exercise=TRUE}
extract_substrs <- function(s, l) {
  
}
extract_substrs("cat", 2)
```

```{r str_sub_str_length-hint}
extract_substrs <- function(s, l) {
  starts <- 
  ends <- 
  str_sub(s, starts, ends)
}
extract_substrs("cat", 2)
```

```{r str_sub_str_length-solution}
extract_substrs <- function(s, l) {
  starts <- seq_len(str_length(s) - (l - 1))
  ends <- starts + l - 1
  str_sub(s, starts, ends)
}
extract_substrs("cat", 2)
# A more complicated example use
substrs <- extract_substrs("The University of Michigan", 8)
prefixes <- strrep(" ", seq_along(substrs) - 1)
writeLines(str_c(prefixes, substrs))
```

### Question

Recall that the `starwars` tibble contains information on various Star Wars characters.
```{r}
head(starwars)
```

For each character, `skin_color` gives their skin colors in a single string. Make a table with the number of characters for each skin color.

**Hint:** *Try using `unlist()` and `table()`*

```{r str_split, exercise=TRUE}

```

```{r str_split-solution}
starwars %>%
  pull(skin_color) %>%
  str_split(", ") %>%
  unlist() %>%
  table() %>%
  sort(decreasing = TRUE)
```

## Regular Expressions

A *regular expression* is a string specifying a pattern that other strings may or may not match. Regular expressions can be used to

  - find strings matching a pattern
  - modify substrings matching a pattern
  - delete substrings matching a pattern
  
An example use of regular expressions is validation of email addresses. If a company wants to check whether a customer's email address is valid, they could check whether it matches a regular expression like [this one](https://stackoverflow.com/a/201378):

```
(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])
```

### Metacharacters

Several characters have special meanings inside regular expressions. They are called *metacharacters*. These are the metacharacters:

`. \ | ( ) [ ] ^ $ { } * + ?`

If you do *not* want a metacharacter to have its special meaning, you need to prepend it with a backslash: `\.`

### Character Classes

- `.` matches any character
- `[abcd]` matches any one of the characters between the brackets
- `[^abcd]` matches any character *not* between the brackets (excluding `^`)
- `[a-d]` matches any character in the specified range; it's the same as `[abcd]`

### Shorthand

- `\w` matches a "word" character, equivalent to `[0-9A-Za-z_]`, i.e., digits, letters, and the underscore
- `\s` matches any whitespace character, including tabs and newlines
- `\d` matches digits, equivalent to `[0-9]`
- `\W`, `\S`, and `\D` match the opposite of the lower-case versions

### Grouping

- `()` are used to group patterns together. This can be used to extract portions of a regex out individually, which we will later learn.
- `\1` refers to match to the first group, `\2` refers to the match to the second group, etc.

### Operators

- `|` is the OR operator and allows matches of either side
- `{}` describes how many times the preceeding character or group must occur:
  - `{m}` must occur exactly `m` times
  - `{m,n}` must occur between `m` and `n` times, inclusive
  - `{m,}` Must occur at least `m` times
- `*` means the preceeding character can appear zero or more times, equivalent to `{0,}`
- `+` means the preceeding character must appear one or more times, equivalent to `{1,}`
- `?` means the preceeding character can appear zero or one time, equivalent to `{0,1}`

### Anchors

- `^` matches the start of a string (or line)
- `$` matches the end of a string (or line)
- `\b` matches a word boundary
- `\B` matches not word boundary

### Examples

The examples below use this paragraph.

```{r}
baseball <- "According to Baseball Reference’s wins above average, The Red Sox had the best 
outfield in baseball— one-tenth of a win ahead of the Milwaukee Brewers, 11.5 to 11.4. And 
that’s despite, I’d argue, the two best position players in the NL this year (Christian 
Yelich and Lorenzo Cain) being Brewers outfielders. More importantly, the distance from 
Boston and Milwaukee to the third-place Yankees is about five wins. Two-thirds of the Los 
Angeles Angels’ outfield is Mike Trout (the best player in baseball) and Justin Upton (a 
four-time All-Star who hit 30 home runs and posted a 122 OPS+ and .348 wOba this year), 
and in order to get to 11.5 WAA, the Angels’ outfield would have had to replace right 
fielder Kole Calhoun with one of the three best outfielders in baseball this year by WAA."
```

#### Example

Write a regex that captures all the capitalized words in the paragraph.

```{r}
# `\b` looks for a word boundary (not just the beginning of the text snippet!)
# `[A-Z]` matches a single capitalized letter
# `[a-z]` matches a single lowercase letter
# `+` means we match arbitrarily many lowercase letters
str_extract_all(baseball, "\\b[A-Z][a-z]+")
```

#### Example

Write a regex that captures all the numbers.

```{r}
str_extract_all(baseball, "\\.?\\d+\\.?\\d*")
```

#### Example

Write a regex that captures all the hyphenated words.

```{r}
str_extract_all(baseball, "\\w+-\\w+") # \w stands for an arbitrary letter
```

#### Example

Write a regex that captures all words with two consecutive wovels.

```{r}
str_extract_all(baseball, "\\w*[aeiou]{2}\\w*")
```

#### Example

Write a regex that captures all words with a repeated letter.

```{r}
# \\1 is a backreference that matches the () group
# An alternative: str_extract_all(baseball, "\\w*([\\w])\\1\\w*")
str_extract_all(baseball, "\\w*([a-zA-Z])\\1\\w*")
```

#### Example

Write a regex that matches `"this"` and `"the"` but not `"third"`.

```{r}
str_extract_all(baseball, "th(e|is)")
str_extract_all(baseball, "(t|T)h(e|is)") # including capitalized T
```

## Exercises

Use `stringr::words` to do the exercises.

### Question

Which words start with `"y"`?

**Hint:** *Use `str_subset()`.*

```{r regex1, exercise=TRUE}

```

```{r regex1-solution}
str_subset(words, "^y")
```

### Question

Which words end with `"x"`?

```{r regex2, exercise=TRUE}

```

```{r regex2-solution}
str_subset(words, "x$")
```

### Question

Without using `str_length()`, find the words that are exactly two letters long.

```{r regex3, exercise=TRUE}

```

```{r regex3-solution}
str_subset(words, "^\\w{2}$")
```

### Question

Without using `str_length()`, find the words that have ten or more letters.

```{r regex4, exercise=TRUE}

```

```{r regex4-solution}
str_subset(words, "^\\w{10,}$")
```

### Question

Which words end with `"ed"`, but not with `"eed"`?

```{r regex5, exercise=TRUE}

```

```{r regex5-solution}
str_subset(words, "[^e]ed$")
```

### Question

Which words end with `"ing"` or `"ise"`?

```{r regex6, exercise=TRUE}

```

```{r regex6-solution}
str_subset(words, "(ing|ise)$")
```

### Question

Which words end with the same two-letter sequence that they start with? An example of such a word would be `"church"`.

```{r regex7, exercise=TRUE}

```

```{r regex7-solution}
# Match two word characters: \\w{2}
# Since we're interested in the two word characters at the start, use the start anchor: ^\\w{2}
# Since we want the same two word characters to be at the end, we should insert parentheses so we can use a backreference: ^(\\w{2})
# Zero or more word characters can exist in the middle: ^(\\w{2})\\w*
# We want the two word characters at the start to be at the end as well. We use a backreference and the end anchor:
str_subset(words, "^(\\w{2})\\w*\\1$")
```

### Question

Try to match the valid `dates` below (first row) without matching the invalid dates (the latter six rows).

**Hint:** *Start by writing a pattern that matches all the entries. Then try to refine your pattern to omit the invalid dates.*

```{r regex8, exercise=TRUE}
dates <- c(
  "2012-05-13", "2014-12-31", "1991-06-14", "1991/06/14", # valid
  "200a-05-13", # invalid year
  "2014-15-20", # invalid month
  "2014-00-20", # invalid month
  "2016-04-35", # invalid day
  "2014-12-00", # invalid day
  "2013/03-25" # non-matching separators
)
```

```{r regex8-solution}
dates <- c(
  "2012-05-13", "2014-12-31", "1991-06-14", "1991/06/14", # valid
  "200a-05-13", # invalid year
  "2014-15-20", # invalid month
  "2014-00-20", # invalid month
  "2016-04-35", # invalid day
  "2014-12-00", # invalid day
  "2013/03-25" # non-matching separators
)
str_subset(dates, "\\d{4}(-|/)(0[1-9]|1[0-2])\\1(0[1-9]|[12][0-9]|3[0-1])")
```