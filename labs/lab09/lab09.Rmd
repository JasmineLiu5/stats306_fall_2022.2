---
title: "Stats 306: Lab 9"
author: "Your Name"
output: 
  learnr::tutorial:
    progressive: true
runtime: shiny_prerendered
---

## Set up

```{r installPackages, echo=FALSE, include=FALSE, message=FALSE}
# This just checks if students need to install some packages that they might 
# not have.

if (!packageVersion("learnr") == "0.11.1") install.packages("learnr", repos = "http://cran.us.r-project.org")
```

```{r setup, eval=TRUE, include=FALSE, message=FALSE, echo=FALSE}
library(learnr)     # For interactive exercises
library(tidyverse)  # For dplyr, stringr

tutorial_options(exercise.reveal_solution=TRUE)
```

```{r fake_setup, echo=TRUE, eval=FALSE}
library(learnr)     # For interactive exercises
library(tidyverse)  # For dplyr, stringr
```

## Logistics

- Exam 2 is due by 11:59 PM on Nov 11.
- Quiz 4 is due by 11:59 PM on Nov 20.
- Questions?

## Today's Content

- Strings and Regular Expressions

## Strings

Recall that a string is character data enclosed in double `"` or single `'` quotes. In R, strings exist in character vectors.
```{r}
words[1:5]
```

The `stringr` package contains many useful functions for working with strings. In lecture, we went over some commonly used `stringr` functions.

`str_c()` is used to concatenate strings. These strings can be given in separate vectors, in which case the `sep` argument should be used to control what goes between consecutive strings.
```{r}
str_c("lions", "tigers", "bears", "oh my!", sep = ", ")
```

`str_c()` can also be given a single vector of strings. In this case, the `collapse` argument should be used to control what goes between consecutive strings.
```{r}
parts <- c("lions", "tigers", "bears", "oh my!")
str_c(parts, collapse = ", ")
```

`str_length()` essentially returns the number of characters in a string.
```{r}
str_length("My favorite colors are maize and blue.")
```

`str_sub()` extracts a substring of a string. `start` and `end` are the indices of the starting and ending characters of the substring.
```{r}
str_sub("November", start = 3, end = 6)
```

`str_split()` splits a string into substrings given a separator. Note that it returns a list.
```{r}
str_split("lions, tigers, bears, oh my!", pattern = ", ")
```

## Exercises

### Question

Using the `letters` vector that's in base R, make one big 26-character string that contains every letter of the alphabet.

```{r str_c1, exercise=TRUE}

```

```{r str_c1-solution}
str_c(letters, collapse = "")
```

### Question

Using the `LETTERS` vector, make a vector with 25 strings in which the first string is `"A precedes B"`, the second string is `"B precedes C"`, etc.

```{r str_c2, exercise=TRUE}

```

```{r str_c2-hint}
# A start
str_c(LETTERS[-26], "precedes", sep = " ")
```

```{r str_c2-solution}
str_c(LETTERS[-26], "precedes", LETTERS[-1], sep = " ")
```

### Question

Finish writing the function `extract_substrs()` below. The function takes a string `s` and a length `l` and should return a vector containing the length `l` substrings of `s` that consist of consecutive characters. For example, `extract_substrs("cat", 2)` should evaluate to `c("ca", "at")`.

**Hint:** *Try using `:` or `seq_len()`*

```{r str_sub_str_length, exercise=TRUE}
extract_substrs <- function(s, l) {
  
}
extract_substrs("cat", 2)
```

```{r str_sub_str_length-hint}
extract_substrs <- function(s, l) {
  starts <- 
  ends <- 
  str_sub(s, starts, ends)
}
extract_substrs("cat", 2)
```

```{r str_sub_str_length-solution}
extract_substrs <- function(s, l) {
  starts <- seq_len(str_length(s) - (l - 1))
  ends <- starts + l - 1
  str_sub(s, starts, ends)
}
extract_substrs("cat", 2)
# A more complicated example use
substrs <- extract_substrs("The University of Michigan", 8)
prefixes <- strrep(" ", seq_along(substrs) - 1)
writeLines(str_c(prefixes, substrs))
```

### Question

Recall that the `starwars` tibble contains information on various Star Wars characters.
```{r}
head(starwars)
```

For each character, `skin_color` gives their skin colors in a single string. Make a table with the number of characters for each skin color.

**Hint:** *Try using `unlist()` and `table()`*

```{r str_split, exercise=TRUE}

```

```{r str_split-solution}
starwars %>%
  pull(skin_color) %>%
  str_split(", ") %>%
  unlist() %>%
  table() %>%
  sort(decreasing = TRUE)
```

## Regular Expressions

## Exercises

Use `stringr::words` to do the exercises.

### Question

Which words start with `"y"`?

**Hint:** *Use `str_subset()`.*

```{r regex1, exercise=TRUE}

```

```{r regex1-solution}
str_subset(words, "^y")
```

### Question

Which words end with `"x"`?

```{r regex2, exercise=TRUE}

```

```{r regex2-solution}
str_subset(words, "x$")
```

### Question

Without using `str_length()`, find the words that are exactly two letters long.

```{r regex3, exercise=TRUE}

```

```{r regex3-solution}
str_subset(words, "^\\w{2}$")
```

### Question

Without using `str_length()`, find the words that have ten or more letters.

```{r regex4, exercise=TRUE}

```

```{r regex4-solution}
str_subset(words, "^\\w{10,}$")
```

### Question

Which words end with `"ed"`, but not with `"eed"`?

```{r regex5, exercise=TRUE}

```

```{r regex5-solution}
str_subset(words, "[^e]ed$")
```

### Question

Which words end with `"ing"` or `"ise"`?

```{r regex6, exercise=TRUE}

```

```{r regex6-solution}
str_subset(words, "(ing|ise)$")
```

### Question

Which words end with the same two-letter sequence that they start with? An example of such a word would be `"church"`.

```{r regex7, exercise=TRUE}

```

```{r regex7-solution}
# Match two word characters: \\w{2}
# Since we're interested in the two word characters at the start, use the start anchor: ^\\w{2}
# Since we want the same two word characters to be at the end, we should insert parentheses so we can use a backreference: ^(\\w{2})
# Zero or more word characters can exist in the middle: ^(\\w{2})\\w*
# We want the two word characters at the start to be at the end as well. We use a backreference and the end anchor:
str_subset(words, "^(\\w{2})\\w*\\1$")
```

### Question

Try to match the valid `dates` below (first row) without matching the invalid dates (the latter six rows).

**Hint:** *Start by writing a pattern that matches all the entries. Then try to refine your pattern to omit the invalid dates.*

```{r regex8, exercise=TRUE}
dates <- c(
  "2012-05-13", "2014-12-31", "1991-06-14", "1991/06/14", # valid
  "200a-05-13", # invalid year
  "2014-15-20", # invalid month
  "2014-00-20", # invalid month
  "2016-04-35", # invalid day
  "2014-12-00", # invalid day
  "2013/03-25" # non-matching separators
)
```

```{r regex8-solution}
dates <- c(
  "2012-05-13", "2014-12-31", "1991-06-14", "1991/06/14", # valid
  "200a-05-13", # invalid year
  "2014-15-20", # invalid month
  "2014-00-20", # invalid month
  "2016-04-35", # invalid day
  "2014-12-00", # invalid day
  "2013/03-25" # non-matching separators
)
str_subset(dates, "\\d{4}(-|/)(0[1-9]|1[0-2])\\1(0[1-9]|[12][0-9]|3[0-1])")
```