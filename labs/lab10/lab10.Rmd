---
title: "Stats 306: Lab 10"
author: "Your Name"
output: 
  learnr::tutorial:
    progressive: true
runtime: shiny_prerendered
---

## Set up

```{r installPackages, echo=FALSE, include=FALSE, message=FALSE}
# This just checks if students need to install some packages that they might 
# not have.

if (!packageVersion("learnr") == "0.11.1") 
  install.packages("learnr", repos = "http://cran.us.r-project.org")
```

```{r setup, eval=TRUE, include=FALSE, message=FALSE, echo=FALSE}
library(learnr)     # For interactive exercises
library(tidyverse)  # For dplyr, stringr

tutorial_options(exercise.reveal_solution=FALSE)
```

```{r fake_setup, echo=TRUE, eval=FALSE}
library(learnr)     # For interactive exercises
library(tidyverse)  # For dplyr, stringr
```

## Logistics

- Quiz 4 is due by 11:59 PM on Nov 20.
- **Lab will be held on Nov 22.**
- Homework 5 is due by 11:59 PM on Dec 4.

## Today's Content

- HW4 Review
- Strings and Regular Expressions

## Strings

Recall that a **string** is a sequence of characters.

Below is an example of a string as it would appear on paper.
```
backyard
```

Strings in R work differently than they do on paper. In R, a string **must either begin and end with a double quote `"` or begin and end with a single quote `'`.**
```{r}
"backyard"
'backyard'
```

**Question:** What would happen if you entered `"backyard"` without the quotes and why?
```{r no_quotes, exercise=TRUE}

```

```{r no_quotes-solution}
backyard
# Without the quotes, the interpreter would assume that backyard is an
# object that we want to print. It wouldn't be able to find backyard because
# it doesn't exist and would then throw an error.
```

`writeLines()` takes the R version of a string and shows us the paper version.
```{r, comment=NA}
writeLines("backyard")
```

Certain characters are inserted in strings using **escape sequences**. An escape sequence starts with a backslash `\`. For example, the escape sequence for `tab` is `\t`. The backslash combines with the next character to form an escape sequence. This is how a tab would be inserted in the previous string.
```{r}
"back\tyard"
```

This may be more natural, but it's worse because it's ambiguous.
```{r}
"back    yard"
```

To include a backslash, use the escape sequence `\\`.
```{r}
"back\\yard"
```

Another commonly used escape sequence is the newline escape sequence. A newline represents the start of a new line.
```{r}
"back\nyard"
```

**Question:** What would happen if you tried to insert a tab, or a backslash, or a newline in the middle of `"backyard"` without using an escape sequence and why? 
```{r escape_seqs, exercise=TRUE}

```

```{r escape_seqs-solution}
# Inserting a tab by hitting the tab key doesn't work. In the console, it would
# bring up the autocomplete box.
# Inserting a backslash with just one backslash causes \y to be interpreted as
# an escape sequence, which causes an error as \y isn't a valid escape
# sequence.
# Inserting a newline by hitting the return key seems to work, but R seems to
# think that the code has a mistake
```

Here are the outputs of `writeLines()` for the three modifications of `"backyard"`. They look the way they would on paper.
```{r, comment=NA}
writeLines("back\tyard")
writeLines("back\\yard")
writeLines("back\nyard")
```

Since quotes are used to mark the start and end of an R string, an escape sequence must be used to put a quote in the middle of an R string if it's of the same type as the start and end quotes.
```{r, comment=NA}
"back\"yard" 
writeLines("back\"yard")
```

**Question:** What happens if you don't escape and why?
```{r no_escaping, exercise=TRUE}

```

```{r no_escaping-solution}
# The interpreter sees the middle quote and thinks that the string has ended,
# but then sees another character, which doesn't make any sense, so it throws
# an error
"back"yard"
```

However, if the quote is of the other type, escaping isn't necessary.
```{r, comment=NA}
"back'yard"
writeLines("back'yard")
```

## Exercises

### Question

Using the `letters` vector that's in base R, make one big 26-character string that contains every letter of the alphabet.

```{r str_c1, exercise=TRUE}

```

```{r str_c1-solution}
str_c(letters, collapse = "")
```

### Question

Finish writing the function `extract_substrs()` below. The function takes a string `s` and a length `l` and should return a vector containing the length `l` substrings of `s` that consist of consecutive characters. For example, `extract_substrs("cat", 2)` should evaluate to `c("ca", "at")`.

**Hint:** *Try using `:` or `seq_len()`*

```{r str_sub_str_length, exercise=TRUE}
extract_substrs <- function(s, l) {
  
}
extract_substrs("cat", 2)
```

```{r str_sub_str_length-hint}
extract_substrs <- function(s, l) {
  starts <- 
  ends <- 
  str_sub(s, starts, ends)
}
extract_substrs("cat", 2)
```

```{r str_sub_str_length-solution}
extract_substrs <- function(s, l) {
  starts <- seq_len(str_length(s) - (l - 1))
  ends <- starts + l - 1
  str_sub(s, starts, ends)
}
extract_substrs("cat", 2)
# A more complicated example use
substrs <- extract_substrs("The University of Michigan", 8)
prefixes <- strrep(" ", seq_along(substrs) - 1)
writeLines(str_c(prefixes, substrs))
```

### Question

Recall that the `starwars` tibble contains information on various Star Wars characters.
```{r}
head(starwars)
```

For each character, `skin_color` gives their skin colors in a single string. Make a table with the number of characters for each skin color.

**Hint:** *Try using `unlist()` and `table()`*

```{r str_split, exercise=TRUE}

```

```{r str_split-solution}
starwars %>%
  pull(skin_color) %>%
  str_split(", ") %>%
  unlist() %>%
  table() %>%
  sort(decreasing = TRUE)
```

## Regular Expressions

A *regular expression* is a string specifying a pattern that other strings may or may not match. Regular expressions can be used to

  - find strings matching a pattern
  - modify substrings matching a pattern
  - delete substrings matching a pattern
  
An example use of regular expressions is validation of email addresses. If a company wants to check whether a customer's email address is valid, they could check whether it matches a regular expression like [this one](https://stackoverflow.com/a/201378):

```
(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])
```

### Metacharacters

Several characters have special meanings inside regular expressions. They are called *metacharacters*. These are the metacharacters:

`. \ | ( ) [ ] ^ $ { } * + ?`

If you do *not* want a metacharacter to have its special meaning, you need to prepend it with a backslash: `\.`

### Character Classes

- `.` matches any character
- `[abcd]` matches any one of the characters between the brackets
- `[^abcd]` matches any character *not* between the brackets (excluding `^`)
- `[a-d]` matches any character in the specified range; it's the same as `[abcd]`

### Shorthand

- `\w` matches a "word" character, equivalent to `[0-9A-Za-z_]`, i.e., digits, letters, and the underscore
- `\s` matches any whitespace character, including tabs and newlines
- `\d` matches digits, equivalent to `[0-9]`
- `\W`, `\S`, and `\D` match the opposite of the lower-case versions

### Grouping

- `()` are used to group patterns together. This can be used to extract portions of a regex out individually, which we will later learn.
- `\1` refers to match to the first group, `\2` refers to the match to the second group, etc.

### Operators

- `|` is the OR operator and allows matches of either side
- `{}` describes how many times the preceeding character or group must occur:
  - `{m}` must occur exactly `m` times
  - `{m,n}` must occur between `m` and `n` times, inclusive
  - `{m,}` Must occur at least `m` times
- `*` means the preceeding character can appear zero or more times, equivalent to `{0,}`
- `+` means the preceeding character must appear one or more times, equivalent to `{1,}`
- `?` means the preceeding character can appear zero or one time, equivalent to `{0,1}`

### Anchors

- `^` matches the start of a string (or line)
- `$` matches the end of a string (or line)
- `\b` matches a word boundary
- `\B` matches not word boundary

### Examples

The examples below use this paragraph.

```{r}
baseball <- "According to Baseball Reference’s wins above average, The Red Sox had the best 
outfield in baseball— one-tenth of a win ahead of the Milwaukee Brewers, 11.5 to 11.4. And 
that’s despite, I’d argue, the two best position players in the NL this year (Christian 
Yelich and Lorenzo Cain) being Brewers outfielders. More importantly, the distance from 
Boston and Milwaukee to the third-place Yankees is about five wins. Two-thirds of the Los 
Angeles Angels’ outfield is Mike Trout (the best player in baseball) and Justin Upton (a 
four-time All-Star who hit 30 home runs and posted a 122 OPS+ and .348 wOba this year), 
and in order to get to 11.5 WAA, the Angels’ outfield would have had to replace right 
fielder Kole Calhoun with one of the three best outfielders in baseball this year by WAA."
```

#### Example

Write a regex that captures all the capitalized words in the paragraph.

```{r}
# `\b` looks for a word boundary (not just the beginning of the text snippet!)
# `[A-Z]` matches a single capitalized letter
# `[a-z]` matches a single lowercase letter
# `+` means we match arbitrarily many lowercase letters
str_extract_all(baseball, "\\b[A-Z][a-z]+")
```

#### Example

Write a regex that captures all the numbers.

```{r}
str_extract_all(baseball, "\\.?\\d+\\.?\\d*")
```

#### Example

Write a regex that captures all the hyphenated words.

```{r}
str_extract_all(baseball, "\\w+-\\w+") # \w stands for an arbitrary letter
```

#### Example

Write a regex that captures all words with two consecutive wovels.

```{r}
str_extract_all(baseball, "\\w*[aeiou]{2}\\w*")
```

#### Example

Write a regex that captures all words with a repeated letter.

```{r}
# \\1 is a backreference that matches the () group
# An alternative: str_extract_all(baseball, "\\w*([\\w])\\1\\w*")
str_extract_all(baseball, "\\w*([a-zA-Z])\\1\\w*")
```

#### Example

Write a regex that matches `"this"` and `"the"` but not `"third"`.

```{r}
str_extract_all(baseball, "th(e|is)")
str_extract_all(baseball, "(t|T)h(e|is)") # including capitalized T
```

## Exercises

Use `stringr::words` to do the exercises.

### Question

Which words end with the same two-letter sequence that they start with? An example of such a word would be `"church"`.

```{r regex7, exercise=TRUE}

```

```{r regex7-solution}
# Match two word characters: \\w{2}
# Since we're interested in the two word characters at the start, use the start anchor: ^\\w{2}
# Since we want the same two word characters to be at the end, we should insert parentheses so we can use a backreference: ^(\\w{2})
# Zero or more word characters can exist in the middle: ^(\\w{2})\\w*
# We want the two word characters at the start to be at the end as well. We use a backreference and the end anchor:
str_subset(words, "^(\\w{2})\\w*\\1$")
```

### Question

Try to match the valid `dates` below (first row) without matching the invalid dates (the latter six rows).

**Hint:** *Start by writing a pattern that matches all the entries. Then try to refine your pattern to omit the invalid dates.*

```{r regex8, exercise=TRUE}
dates <- c(
  "2012-05-13", "2014-12-31", "1991-06-14", "1991/06/14", # valid
  "200a-05-13", # invalid year
  "2014-15-20", # invalid month
  "2014-00-20", # invalid month
  "2016-04-35", # invalid day
  "2014-12-00", # invalid day
  "2013/03-25" # non-matching separators
)
```

```{r regex8-solution}
dates <- c(
  "2012-05-13", "2014-12-31", "1991-06-14", "1991/06/14", # valid
  "200a-05-13", # invalid year
  "2014-15-20", # invalid month
  "2014-00-20", # invalid month
  "2016-04-35", # invalid day
  "2014-12-00", # invalid day
  "2013/03-25" # non-matching separators
)
str_subset(dates, "\\d{4}(-|/)(0[1-9]|1[0-2])\\1(0[1-9]|[12][0-9]|3[0-1])")
```