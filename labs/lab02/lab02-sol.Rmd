---
title: "STATS306 Lab2"
author: "Your Name"
output: 
  html_document:
    number_sections: true
runtime: shiny_prerendered
---

<style type="text/css">
  body{
  font-size: 14pt;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(learnr)
library(tidyverse)
```

# Logistics

- Quiz 2 is due by 11:59 PM on 9/25.
- The HW1 deadline has been pushed back one week; it's now due by 11:59 PM on 9/25.
- HW2 will be released on 9/18 and will be due by 11:59 PM on 10/2.

# Plotting with `ggplot2`

Recall from lecture that a plot made using `ggplot2` has several components:

* The graph object itself (creating using `ggplot(data)`)
* A set of *aesthetic* mappings (connecting data to visual variables)
* Layers: collections of geometric elements (`geom_*()`) and statistical transformations (`stat_*()`)
* Scales: information on the range or composition of variables
* Coordinate systems: how the data are arranged spatially
* Facet: breaking a single plot into many, similar plots
* Theme: all the other color and printing aspects of the plot

Today we'll talk about aesthetic mappings, geometric elements, and statistical transformations.

## Aesthetic Mappings

An *aesthetic* is a visual property of the geometric elements in a plot.

```{r aesthetic_mappings_example1}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = cty, y = hwy, color = drv))
```

Geometric elements represent observations in the dataset. In the plot above, the points are the geometric elements. Different geometric elements have different aesthetics. Some aesthetics of points are

* `x`, or x-coordinate
* `y`, or y-coordinate
* `color`
* `shape`
* `size`

The background, the gridlines, and the tick marks are not geometric elements because they don't represent any observations. This means that properties like the background color aren't aesthetics.

An *aesthetic mapping* is an assignment of an aesthetic to a variable in the dataset. Aesthetic mappings are listed inside `aes()`. For example, in the previous plot, the aesthetic `x` was mapped to the variable `cty`. 

Each layer has a set of aesthetic mappings. By default, a layer inherits its mappings from the base created by `ggplot()`. So, the code for the plot above could be changed to

```{r aesthetic_mappings_example2}
ggplot(data = mpg, mapping = aes(x = cty, y = hwy, color = drv)) + 
  geom_point()
```

### Exercise 1 {-}

#### (a) {-}

Modify the code below so that the point shape varies by drive train (`drv` value).

```{r exercise1a, exercise=TRUE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = cty, y = hwy, color = drv, shape = drv))
```

#### (b) {-}

Modify the code below so that each point is a triangle. How is your code different from your code for part (a)? Why is it different?

*Hint: use the string "triangle"*

```{r exercise1b, exercise=TRUE}
# The key difference here is that the shape = part goes outside aes() instead
# of inside aes(). This is because here we're setting shape to a constant
# instead of mapping it to a variable. Only aesthetic mappings go inside
# aes().
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = cty, y = hwy, color = drv), shape = "triangle")
```

## Geometric Elements

A *geometric element* or *geom* is a geometric object that is used in a plot to represent observations. A geom can represent

  * one observation;
  * a group of observations;
  * all of the observations.

A `ggplot2` plot consists of a base created by `ggplot()` and zero or more layers, each representing observations in a particular dataset using a particular geom. There are many geoms; several commonly used geoms are described below. The examples visualize a dataset called `midwest` that has data from the 2000 census on counties in several midwestern states.

```{r convert_inmetro}
# inmetro is an integer that equals 0 or 1; plots will look better if it's
# logical
midwest <- mutate(midwest, inmetro = as.logical(inmetro))
```


### Plotting the Distribution of One Variable

If we want to visualize the distribution of a single variable, we first need to determine whether it's categorical or numerical.

If the variable is categorical, then we can make a bar chart. We use `geom_bar()` to do this. The plot below shows the number of counties by state.

```{r geom_bar_example}
midwest %>%
  ggplot(aes(state)) +
  geom_bar()
```

There are several options if the variable is numerical. `perchsd` gives the percentage of high school graduates. We could make a histogram of `perchsd` using `geom_histogram()`.

```{r geom_histogram_example}
midwest %>%
  ggplot(aes(perchsd)) +
  geom_histogram()  
```

We could also make a frequency polygon with `geom_freqpoly()`.

```{r geom_freqpoly_example}
midwest %>%
  ggplot(aes(perchsd)) +
  geom_freqpoly()
```

Finally, we could use `geom_boxplot()` to make a boxplot.

```{r geom_boxplot_example1}
midwest %>%
  ggplot(aes(perchsd)) +
  geom_boxplot()
```

### Plotting the Relationship between Two Variables

Just like in the one variable case, when we have two variables, we first need to determine the types of the variables before we make our plot.

We can make a scatterplot with `geom_point()` if both variables are numerical. The plot below displays the relationship between `perchsd` and `percadultpoverty`, the percentage of adults below the poverty line.

```{r geom_point_example}
midwest %>%
  ggplot(aes(perchsd, percadultpoverty)) +
  geom_point()
```

Instead of plotting all of the points, we could plot a *smooth*, a curve that summarizes the trend in the data. This is done with `geom_smooth()`.

```{r geom_smooth_example}
midwest %>%
  ggplot(aes(perchsd, percadultpoverty)) +
  geom_smooth(se = FALSE)
```

#### Exercise 2 {-}

##### (a) {-}

Make a plot of `percadultpoverty` versus `perchsd` that has both points and a smooth.

```{r exercise2a, exercise=TRUE}
midwest %>%
  ggplot(aes(perchsd, percadultpoverty)) +
  geom_point() +
  geom_smooth(se = FALSE)
```

##### (b) {-}

Make a plot that is the same as the one in part (a), except with a confidence interval around the smooth. What do you notice about the width of the interval? Why does it make sense for the width to be how it is?

*Hint: look at the help page for `geom_smooth()` to make the interval*

```{r exercise2b, exercise=TRUE}
# The width increases toward the sides of the plot. This makes sense, as there
# are few points near the sides, so the estimates of the trend there should be
# highly uncertain.
midwest %>%
  ggplot(aes(perchsd, percadultpoverty)) +
  geom_point() +
  geom_smooth() # Inserting se = TRUE is unnecessary since se = TRUE by default
```

##### (c) {-}

You might have noticed that the smooth in part (b) was calculated using a method called LOESS. Other methods can be used as well. Remake the plot, but with a smooth calculated using linear regression.

*Hint: look at the help page for `geom_smooth()` again*

```{r exercise2c, exercise=TRUE}
midwest %>%
  ggplot(aes(perchsd, percadultpoverty)) +
  geom_point() +
  geom_smooth(method = "lm") # lm() is the function used for linear regression
```

A boxplot is one option if one variable is categorical and one is numerical. The following plot shows the distribution of `percollege`, the percentage of college graduates, by state.

```{r geom_boxplot_example2}
midwest %>%
  ggplot(aes(state, percollege)) +
  geom_boxplot()
```

We could also make a bar chart using `geom_col()`. Below, `midwest2` contains one row per state in `midwest` and has the number of counties for each state. We can use `geom_col()` to recreate the bar chart made with `geom_bar()` above.

```{r geom_col_example}
midwest2 <- midwest %>%
  group_by(state) %>%
  summarize(num_counties = n())
midwest2 %>%
  ggplot(aes(state, num_counties)) +
  geom_col()
```

#### Exercise 3 {-}

##### (a) {-}

Instead of using boxplots to visualize the relationship between `percollege` and `state`, we could use histograms. Make one plot that has a histogram of `percollege` for each value of `state`. Give the histograms different colors. How does this plot compare to the boxplot?

```{r exercise3a, exercise=TRUE}
# This plot is harder to read than the boxplot. However, unlike the boxplot, it
# does show that the different states have different numbers of counties.
midwest %>%
  ggplot(aes(percollege, color = state)) +
  geom_histogram()
```

##### (b) {-}

Now make a one plot that has a frequency polygon for each state instead of a histogram. Give the frequency polygons different colors. How does this plot compare to the preceding plots?

```{r exercise3b, exercise=TRUE}
# This plot is also hard to read, and it also shows the count information that
# the boxplot doesn't show.
midwest %>%
  ggplot(aes(percollege, color = state)) +
  geom_freqpoly()
```

##### (c) {-}

Complete the code below to use boxplots to visualize the relationship between `inmetro` and `percollege`. `inmetro` is `TRUE` if a county is in a metro area and false otherwise.

```{r exercise3c, exercise=TRUE}
midwest %>%
  mutate(inmetro = as.logical(inmetro)) %>%
  ggplot(aes(inmetro, percollege)) +
  geom_boxplot()
```

##### (d) {-}

Now complete the code to use frequency polygons to visualize the relationship. Is this plot worse than the boxplot?

```{r exercise3d, exercise=TRUE}
# Unlike the previous frequency polygon plot, this one isn't hard to read. This
# plot provides count information that the boxplot doesn't provide. So, unlike
# previously, the frequency polygon plot isn't worse than the boxplot.
midwest %>%
  mutate(inmetro = as.logical(inmetro)) %>%
  ggplot(aes(percollege, color = inmetro)) +
  geom_freqpoly()
```

Finally, if both variables are categorical, we can plot them using `geom_count()`.

```{r geom_count_example}
midwest %>%
  ggplot(aes(state, inmetro)) +
  geom_count()
```

